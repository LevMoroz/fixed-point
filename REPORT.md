| Лабораторная работа №1.1 | 23.Б10    | Архитектура компьютера |
| :--------------------- | ----------- | ---- |
| Представление чисел. Фикс. точка.    | Морозов Лев Станиславич       | 2024 |

## Инструментарий
С++20, компилятор msvc (но это не важно).

## Что реализовано
Реалиованы числа в формате фиксированной точки и базовые операции над ними.

# Описание:

Предисловие: решил использовать using'и в файлах для большей лаконичности кода (и удобнее в разработке). Они и все include'ники минимальны.

#### Парсер в main.cpp:
- Сначала проверяем число аргументов.  
- Затем разбираем формат: ищем точку (если нет => исключение), пытаемся прочитать число бит целой части до точки и дробной части после точки (если невозможно, то исключение). Функция stoi, правда, парсит до первого нечислового символа ("123ddd" станет 123), но в целом это неважно.  
- Считываем тип округления и число, его уже в 16-ричном формате. Чтобы точно ничего не пропало используется uint32_t.  
- Создаём объект класса FixedPoint.  
- Если передано 6 аргументов, то есть была и операция, то считаваем её (д.б. один символ) и второе число. Создаём второй объект класса фиксированной точки и выполняем соответствующую операцию (если такой операции нет, то исключение).  
- Затем печатаем первое число, если операция была, то оно уже изменено соответственно. В этом удобство операторов вида += (и не нужно создавать новый объект).  
- Для перехвата исключений описанный выше блок кода обёрнут в try-catch. Если было исключение (throw, stoi или конструктор), то будет напечатано сообщение ошибки в stderr и выход с кодом возврата 1.  

### Класс FixedPoint:

#### Сначала FixedPoint.hpp:  
Enum-класс для красоты и удобства, по сути. Более красиво называет тип округления.  
Итак, класс нашего числа хранит: количество бит целой и дробной части, тип округления и само число. Затем идут публичные функции, которые от нас требуют и функция roundRes общая для деления и умножения.  

#### Теперь перейдём к реализации функций в FixedPoint.cpp:  
- Функция deg2 - для удобства записи. Зачем int64_t станет понятно чуть позже.  
- modOfDeg2 - более удобная запись для максимально быстрого взятия остатка по числу, которое является степенью двойки.  

#### Конструктор:
- Проверяем, что wholePart, fractPart и roundType будут лежать в допустимых диапозонах.  
- Теперь главная идея: хранить число так, чтобы получить модулярную арифметику полностью за бесплатно.  
- uint32_t - можем сдвигать как хотим (не дальше размера числа) по стандарту. Со сдвигом знаковых отрицательных проблемы: сдвиги >> компиляторозависимы; << даже поведение не определено. Переполнение знаковых - UB то же! Потому использую беззнаковый тип.  
- В конструкторе сдвигаем данное нам число влево так, чтобы страший введённый бит стал старшим для uint32_t. Для этого сдвигаем на (32 - wholePart - fractPart) влево, как раз сохраняем (wholePart + fractPart) введённых бит, что и нужно. Все лишние слева биты будут убраны.  
- В каком-то смысле мы храним число в формате A.(32-A), но все лишние биты дробной части обнулены.  
- Итак, получили за бесплатно дополнение до двух: можем перевести uint32_t к int32_t! Поменяется интерпретация битов на нужную нам.  

#### Функция print:
- Приводим num к знаковому типу и только затем расширяем в int64_t (переменная n). Иначе знак числа не сохранился бы. 64 бита нужно для правильности операции n * divisor.  
- Считаем наш знаменатель, это будет как раз 2^(32 - А), поскольку мы дополнительно сдвигали число влево в конструкторе.  
- Вычисляем целую часть для вывода: делим целочисленно whole на denom. Оба обязательно знаковые:  
-8 / 3 = -2, желаемый  
-8 / (unsigned int)3 = 1431655762 (!!!)  (и просто приведение к int не поможет...). Тогда получаем ровно целую часть нашей дроби.  
- divisor - выбираем, сколько хотим десятичных цифр дробной части. Для округления к ближайшему чётному нужно 4, иначе 3.  
- (n * divisor / denom % divisor) - таким образом получаем желаемые цифры. Лишнее отбрасывается делением. Ещё одна причина для большого n, кстати.  
-13 % 10 = -3, так что берем ещё и модуль от этого значения. Знак у нас хранится в whole, здесь он лишний. Число маленькое, приведением в конце хуже не сделаем.  
- Дальнейшие действия зависят от типа округления. Для toZero мы уже отбросили всё лишнее, больше ничего не делаем.  
- Для toNearestEven: округляем в большую сторону, если последняя из 4-ёх цифра > 5 либо она = 5, но: третья цифра нечётная(тогда округляем как раз к чётному) или если у нас был хоть какой-то остаток от деления при вычислении fract (это округление к ближайшему, так как мы тогда ближе к верхнему числу).  
- Если набрали до целого после округления, то увеличиваем whole в зависимости от знака числа на +1 или -1.  
- Для toPosInf смотрим, что число > 0 и есть хоть какой-то остаток при делении на знаменатель (тогда округляем вверх), иначе отбрасываем, как к 0.  
- Для toNegInf также, только число должно быть <0.  
- Перенос при fract == 1000 можно было бы вынести из блоков switch-case, но тогда была бы лишняя проверка if на все случаи. Поэтому чуть копипасты для оптимизации.  
- Затем выводим дополнительно минус, если это должна быть отрицательная дробь без целой части (т.к. -0 не выведется), и дополняем слева нулями fract, если нужно.  

#### += & -= :
Поскольку округлять здесь нечего, а модулярная арифметика поддерживается самим типом, то ничего больше делать не надо, только поменять num.  

### *= & /= :
- Здесь округление уже необходимо. Сначала берём модули от наших чисел (с учётом знака сначала), сразу приводим к uint64_t. Опять же, модуль минимального не влезает в int, а потому функция abs в этом случае ничего не делает (именно из-за этого она и возвращает int...). Поэтому llabs. Умножая два 32-битных числа (модуль лишнего бита не даст), получим максимум 64-битное, нет потерь.  
- Модуль нужен, ведь иначе возникает проблема, когда знак произведения попросту не влезает в тип и обрезается, нужно дополнительно отдельно обрабатывать. По-моему, этот способ проще.  
- При перемножении получаем число формата 2 * (wholePart + fractPart), причём справа (64 -  2 * (wholePart + fractPart)) нуля, как в исходном формате хранения фиксированной точки, но уже 64 бита. Поэтому сдвигаем вправо на эти нули, потерь нет.  
- Для деления же сначала сдвигаем делимое влево на 32, чтобы результат деления был максимально точным, ведь иначе дробная часть ответа по сути обрезается: (A * deg2(k)) / (B * deg2(k)) = A / B, должны сдвинуть влево на k для возвращения в формат => теряем дробную часть целиком.  
- После самой операции вызываем функцию округления: для умножения нужно округлить fractPart битов справа (чтобы вернуться в формат исходный). Для деления же нужно округлить (32 - fractPart) битов: компенсируем предыдущий сдвиг влево на 32, но оставляем формат исходный (deg2(32) / deg2(32 - fractPart) будет deg2(fractPart) - желаемый формат).  
- Передаём в roundRes результат, сколько округлять и знак результата: xor вернёт число меньшее нуля, только если результат должен быть отрицательным, то есть был ровно 1 страший бит единицей у аргументов. Потом инвертируем результат, если знак будет < 0.  

### roundRes:
- По умлочанию коэфффициент округления равен 0. Для типа округления toZero нужно просто обрезать, поэтому ничего и не делаем.  
- Для toNearestEven ищем ситуации, когда нужно округлять в большую сторону: проверяем, что нам вообще есть что округлять (иначе нет старшего бита дробной части), затем берём старшую цифру округляемой части и проверяем, что это 1 (т.е. != 0). Далее либо младшая цифра r должна быть нечётной, либо в дробной части есть ещё хоть какой-то остаток.  
- Для бесконечностей проверяем, что у результата будет соответствующий знак и есть хоть какой-то остаточек. Сначала проверка на знак для лучшей оптимизации, отрезает половину случаев, когда не тот знак результата, а остаток есть часто.  
- Затем уничтожаем округляемую часть. Прибавляем коэффициент округления, восстанавливаем формат числа, сдвигая его в исходную позицию. Меняем знак, если нужно. И обрезаем лишнее для num. Только сейчас сработала модульная арифметика (как раз после округления, чего и хотим).

- 